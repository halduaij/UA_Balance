----------------------------------------
-- File: 'buildbasestrategy.ai'
-- Edited by Thudmeizer @ 29.09.2005
-- Edited by Corsix     @ 17.01.2005
-- Edited by LarkinVB   @ 28.09.2005
-- Edited by Flenser    @ 02.06.2005
-- Edited by Arkhan     @ 09.12.2005
-- Edited by Dark40k    @ 14.10.2008
-- Edited by Aliaska_RuS

class 'BuildBaseStrategy' (Strategy)

BuildBaseStrategy.iBuildProgram = 1

BuildBaseStrategy.Status =
{
	Defensive = "Defensive",
	Offensive = "Offensive"
}

function BuildBaseStrategy:__init( baseinfo ) super( baseinfo )
	
	-- Workaround for Relic bug
	self.m_bHQAddon1 = false
	self.m_bHQAddon2 = false
	
	-- Maximum amount of generators to build
	self.m_iMaxGenerators = 32
	
	-- Arkhan 10.2005: Decide, which build program to use
	self.m_bSpendMoney = true
	self.m_iPrepareRush = 0
	self.m_iFinishedRush = 0
	if (BuildBaseStrategy.iBuildProgram > table.getn(self.info.BuildPrograms)) then
		BuildBaseStrategy.iBuildProgram = 1
	end

        self.m_iCurrentBuildProgram = 0
        if (CpuManager.AISettings.bAlternativeStrategies) then
		self.m_iCurrentBuildProgram = self:ChooseBuildProgram()
	end

	self.debug_effectiveness = false
	
	self.player_stats = cpu_manager.stats:GetPlayerStatsFromID( cpu_manager.player_id )
	dbAssert( self.player_stats ~= nil )
	
	self:SetStatus( BuildBaseStrategy.Status.Offensive )
	self.military_stance = BuildBaseStrategy.OffensiveStance

	self.num_hq = 1
	self.tierLevel = 1
        self.techongo = false
        self.techongotype = nil
        self.techongoname = "nil"

	self.m_iArmyStrength = 0

	self.unitupdate_enemy = nil

	self:PostEvent( Strategy.Events.OnStart )

    --begin Project QuickStart code
    --begin Project Mapsize code
    --added by Flenser 12 May 2005
    local map_size, iDistanceToEnemy = self:GetMapSize()
    local level = cpu_manager.cpu_player:GetDifficultyLevel()
    
    if level == CpuPlayer.AD_Insane then
        self.info.Engineers.want = self.info.Engineers.want + 1    
    end

        self.post_builder = self.info.post_builder
	--put a cap on tactics spendage
	Tactic.ResourceFloor.requisition = self.info.req_reserve
	
	-- Randomly choose one in the set of squad limits for easier levels
	self.m_iSquadLimit = 0
	for iLoop1 in self.info.SquadLimits do
		self.m_iSquadLimit = self.m_iSquadLimit + 1
	end
	self.m_iSquadLimit = math.random( 1, self.m_iSquadLimit )
	
	-- Check for massive battles mode
	local fArmyCapModifier = 1.0
	if (CpuManager.AISettings.bMassiveBattlesMode and g_fMassiveBattlesModifier ~= nil) then
		fArmyCapModifier = g_fMassiveBattlesModifier
	end
	
	-- Set the squad limits
	local iIndex = 1
	for iLoop1 in self.info.SquadLimits do
		if (self.m_iSquadLimit == iIndex) then
			print( "player "..cpu_manager.player_id.." has chosen squadlimits: "..iLoop1 )
			for iLoop2 in self.info.SquadLimits[iLoop1] do
				build_manager:SetSquadLimit( iLoop2, math.floor(self.info.SquadLimits[iLoop1][iLoop2] * fArmyCapModifier + 0.5))
			end
			break
		end
		iIndex = iIndex + 1
	end

	-- Set maximums, if needed
	if self.info.no_alternate_objective ~= nil then
		CapturePlan.Maximums.points = resource_manager:GetTotalNumStrategicPoints() / 2
		CapturePlan.Maximums.objectives = resource_manager:GetTotalNumStrategicObjectives() / 2
	end
	
	-- Detector list
	self.m_aDetectors = {}
	
	-- Modify unit demand if we've excess ressources
	self.m_bModifyUnitDemand = true

	-- My rating against the first enemy player
	self.rating = 0
	
	self.m_iNextUpdate = AI_GetPlayerID()-1000
	self.m_iNextUpdateCheckGoTech = AI_GetPlayerID()-1000	
        self.m_iNextUpdateUnitProd = AI_GetPlayerID()-1000
        self.m_iNextUpdateBuilding = AI_GetPlayerID()-1000
 
	-- Init building lists
	self.m_aBuildings = {}
	self.m_aListeningPosts = {}
	self.m_aBuildChannels = {}
	
	-- Check if AI is allied with a human player
	local bAlliedWithHuman = false
	for oPlayer in cpu_manager.stats:GetPlayerStats() do
	
		-- Get player ID
		local iPlayerID = oPlayer:GetPlayerID()
				
		-- Check if player is an ally
		if (cpu_manager:IsFriendly(iPlayerID)) then
		
			-- Check if player is human
			if (AI_GetCpuPlayerFromID(iPlayerID) == nil) then
				bAlliedWithHuman = true
			end
		end
	end
	
	-- Set tech speed
	if (CpuManager.AISettings.iTechSpeed == -2) then
		self.info.ArmyStrengthModifier = self.info.ArmyStrengthModifier * 1.5
	elseif (CpuManager.AISettings.iTechSpeed == -1) then
		self.info.ArmyStrengthModifier = self.info.ArmyStrengthModifier * 1.25
	elseif (CpuManager.AISettings.iTechSpeed == 1) then
		self.info.ArmyStrengthModifier = self.info.ArmyStrengthModifier * 0.75
	elseif (CpuManager.AISettings.iTechSpeed == 2) then
		self.info.ArmyStrengthModifier = self.info.ArmyStrengthModifier * 0.5
	end
	self.info.ArmyStrengthModifier = self.info.ArmyStrengthModifier * math.random(75, 125) / 100
	
	-- Set tech break
	self.m_iTechBreak = 1
	if (bAlliedWithHuman) then
		
		-- Check for handicaps for AI's allied with a human player
		if (CpuManager.AISettings.iHandicap == -1) then
			self.m_iTechBreak = 2
		elseif (CpuManager.AISettings.iHandicap == -2) then
			self.m_iTechBreak = 4
		end
	else
	
		-- Check for handicaps for AI's not allied with a human player
		if (CpuManager.AISettings.iHandicap == 1) then
			self.m_iTechBreak = 2
		elseif (CpuManager.AISettings.iHandicap == 2) then
			self.m_iTechBreak = 4
		end		
	end
	
	-- Workaround squad cap
	self.m_iSquadCap = 0
	self.m_iLastSquadCapCalculation = AI_GetPlayerID()-1000
end

-- Arkhan 10.2005: Chooses a random build program for a race at the start
function BuildBaseStrategy:ChooseBuildProgram()
	return math.random(1, table.getn(self.info.BuildPrograms))
end

function BuildBaseStrategy:GetName()
	return "BuildBaseStrategy"
end

function BuildBaseStrategy:UpdateTierLevel()
   aitrace( "this race does not evaluate tier" )
   self.tierLevel = 1
end

function BuildBaseStrategy:GetTierLevel()
   return self.tierLevel
end

function BuildBaseStrategy:AddDetectorUnit(sUnitName)
	table.insert(self.m_aDetectors, sUnitName)
end

function BuildBaseStrategy:CheckTechBufer()
        if self.techongotype == addon then
        local iTechID = cpu_manager.stats:GetAddOnID(self.techongoname)
	  if (self:PlanExists("Build AddOn Plan", iTechID) == true) then 
		self.techongo = true
          end
        elseif self.techongotype == research then
        local iTechID = cpu_manager.stats:GetResearchID(self.techongoname)
	  if (self:PlanExists("Build Research Plan", iTechID) == true) then 
		self.techongo = true
          end
        elseif self.techongotype == building then
        local iTechID = cpu_manager.stats:GetBuildingID(self.techongoname)
	  if (self:PlanExists("Build Building Plan", iTechID) == true) then 
		self.techongo = true
          end
        end  
end

function BuildBaseStrategy:CheckTech()
        self.techongo = false
end

--increase demand on units with high effectivness against enemy class types
function BuildBaseStrategy:CalculateEffectivenessDemand( enemy_id )

	local enemy_stats = cpu_manager.stats:GetPlayerStatsFromID( enemy_id )
	dbAssert( enemy_stats ~= nil )
	
	for class = 0, UnitStatsAI.UC_Count - 1 do
		local self_eff = self.player_stats:GetTotalEffectivenessRating( class )
		local enemy_class_rating = enemy_stats:GetTotalClassRating( class )

		local difference = self_eff - enemy_class_rating
		-- if < 0 we want more of this type to counter the enemy
		-- else we have enough of this type
		self:IncEffectivenessDemand( class, difference )
	end
end

--increase demand on units that the enemy has low effectivness on or that we no longer want
function BuildBaseStrategy:CalculateClassDemand( enemy_id )

	local enemy_stats = cpu_manager.stats:GetPlayerStatsFromID( enemy_id )
	dbAssert( enemy_stats ~= nil )

	for class = 0, UnitStatsAI.UC_Count - 1 do

		local self_class_rating = self.player_stats:GetTotalClassRating( class )
		local enemy_eff = enemy_stats:GetTotalEffectivenessRating( class )

		local difference = enemy_eff - self_class_rating
		-- if < 0 then we want more this type - the enemy can't counter them well
		-- else they will be countered by the enemy, don't build more for now
		self:IncClassDemand( class, difference )
	end
end

--increase demand on units with high effectivness against enemy class types
--Kaiser 03.2007
function BuildBaseStrategy:CalculateEffectivenessDemandBad( enemy_id )

	local enemy_stats = cpu_manager.stats:GetPlayerStatsFromID( enemy_id )
	dbAssert( enemy_stats ~= nil )
	
	aipushtrace ("BuildBaseStrategy:CalculateEffectivenessDemand")
	for class = 0, UnitStatsAI.UC_Count - 1 do
		local self_eff = self.player_stats:GetTotalEffectivenessRating( class )
		local enemy_class_rating = enemy_stats:GetTotalClassRating( class )

		local difference = enemy_class_rating - self_eff
		--aitrace ("Armour: "..string.format("%02.0f",class).." Self Eff:"..string.format("%9.5f",self_eff).." Enem rating: "..string.format("%9.5f",enemy_class_rating).." Diff: "..string.format("%9.5f",difference))
		-- if > 0 we want more of this type to counter the enemy
		-- else we have enough of this type
		self:IncEffectivenessDemand( class, difference )
	end
	aipoptrace ("BuildBaseStrategy:CalculateEffectivenessDemand has finished")

end

--increase demand on units that the enemy has low effectivness on or that we no longer want
--Kaiser 03.2007
function BuildBaseStrategy:CalculateClassDemandBad( enemy_id )

	local enemy_stats = cpu_manager.stats:GetPlayerStatsFromID( enemy_id )
	dbAssert( enemy_stats ~= nil )
	aipushtrace ("BuildBaseStrategy:CalculateClassDemand")
	local max_enemy_eff = 0
	for class = 0, UnitStatsAI.UC_Count - 1 do
		if max_enemy_eff < enemy_stats:GetTotalEffectivenessRating ( class ) then
			max_enemy_eff = enemy_stats:GetTotalEffectivenessRating ( class )
		end
	end
	--enemy_weight_eff= enemy_weight_eff/UnitStatsAI.UC_Count
	for class = 0, UnitStatsAI.UC_Count - 1 do
		--local self_class_rating = self.player_stats:GetTotalClassRating( class )
		local enemy_eff = enemy_stats:GetTotalEffectivenessRating( class )

		local difference = max_enemy_eff - enemy_eff
		--aitrace ("Armour: "..string.format("%02.0f",class).." Enem Eff:"..string.format("%9.5f",enemy_eff).." Self rating: "..string.format("%9.5f",self_class_rating).." Diff: "..string.format("%9.5f",difference))
		-- if < 0 then we want more this type - the enemy can't counter them well
		-- else they will be countered by the enemy, don't build more for now
		self:IncClassDemand( class, difference )
	end
	aipoptrace ("BuildBaseStrategy:CalculateClassDemand has finished")

end

function BuildBaseStrategy:CalculateAll( enemy_id )
--increase demand on units with high effectivness against enemy class types
	local enemy_stats = cpu_manager.stats:GetPlayerStatsFromID( enemy_id )
	dbAssert( enemy_stats ~= nil )
	local max_enemy_eff = 0

	for class = 0, UnitStatsAI.UC_Count - 1 do
		if max_enemy_eff < enemy_stats:GetTotalEffectivenessRating ( class ) then
			max_enemy_eff = enemy_stats:GetTotalEffectivenessRating ( class )
		end
	end

	for class = 0, UnitStatsAI.UC_Count - 1 do
		local self_eff = self.player_stats:GetTotalEffectivenessRating( class )
		local enemy_class_rating = enemy_stats:GetTotalClassRating( class )

		local self_class_rating = self.player_stats:GetTotalClassRating( class )
		local enemy_eff = enemy_stats:GetTotalEffectivenessRating( class )

		local differenceEffectivness = self_eff - enemy_class_rating
		local differenceEffectivnessBad = enemy_class_rating - self_eff
                differenceEffectivnessBad = differenceEffectivnessBad / 3

		local differenceClass = enemy_eff - self_class_rating
		local differenceClassBed = max_enemy_eff - enemy_eff
                differenceClassBed = differenceClassBed / 3

		self:IncEffectivenessDemand( class, differenceEffectivness )
		self:IncEffectivenessDemand( class, differenceEffectivnessBad )

		self:IncClassDemand( class, differenceClass )
		self:IncClassDemand( class, differenceClassBed )
	end
end

function BuildBaseStrategy:CalculateEngineerDemand()

	local num_engineers = military_manager:GetNumEngineers()
	local limit = self.info.Engineers.want
	local iRequisition = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Requisition )

	-- Additional builders at higher tiers
	if (self.tierLevel == 1) then
        limit = self.info.Engineers.want
        end
	if (self.tierLevel == 2 and self.info.Engineers.tier1~=nil) then
        limit = self.info.Engineers.tier1
        end
	if (self.tierLevel == 3 and self.info.Engineers.tier2~=nil) then
        limit = self.info.Engineers.tier2
        end
	if (self.tierLevel == 4 and self.info.Engineers.tier3~=nil) then
        limit = self.info.Engineers.tier3
        end
	if (self.tierLevel == 5 and self.info.Engineers.tier4~=nil) then
        limit = self.info.Engineers.tier4
        end
        if iRequisition > 1000 then
        limit = 10
        end

	-- Don't exceed max builders and change max builder if not change. Myau.
        if self.info.Engineers.max ~= nil then
	 if (limit > self.info.Engineers.max) or (self.tierLevel > 5) then
		limit = self.info.Engineers.max
         end
        end

	-- Just build some engineers -- don't skew the wants
	if (num_engineers < limit) then
	
		-- Check if a build plan exists for an engineer
		local oBuildPlan = self:GetPlan("Build Unit Plan", cpu_manager:GetEngineerBPID())
		if (oBuildPlan ~= nil) then
			return
		end
		
		-- Check that the main base isn't under attack
		if (cpu_manager:GetCriticalSituation() > 0) then
			return
		end
		
		local build_type = CpuBuildType()
		build_type.btype = CpuPrerequisites.BT_Squad
		build_type.name = cpu_manager.stats:GetSquadName( cpu_manager:GetEngineerBPID() )
		self:TryBuild( build_type )		
	end
end

-- Arkhan 11.2006: Check if a detector unit is needed and try to build the best one available if necessary
function BuildBaseStrategy:CalculateDetectorDemand()

	-- Don't build detector units if enemy has no stealth units
	if (not cpu_manager:EnemyHasUnitInfiltrators() and not cpu_manager:EnemyHasBaseInfiltrators()) then
		return
	end
	
	-- Check for detectors and try to build the best ones if necessary
	for iLoop1 in self.m_aDetectors do
	
		-- Check if we already have this unit
		local iUnitID = cpu_manager.stats:GetSquadID(self.m_aDetectors[iLoop1])	
		local iUnitCount = cpu_manager.player_stats:GetNumSquadsByBPID(iUnitID)
		if (iUnitCount > 0) then
			return
		end
		
		-- Check if a plan exists for the current unit
		if (self:GetPlan("Build Unit Plan", iUnitID) ~= nil) then
			return
		end
	
		-- Try to build unit
		local tBuildType = CpuBuildType()
		tBuildType.btype = CpuPrerequisites.BT_Squad
		tBuildType.name = self.m_aDetectors[iLoop1]
		if (self:TryBuild(tBuildType)) then
			return
		end
	end
end
-- Arkhan 03.2006: Check stance
function BuildBaseStrategy:CheckStance()

	-- Check if we've an attack delay
	if (g_iGMT < CpuManager.AISettings.iAttackDelay * 60) then
		return "Defensive"
	end

	-- If I'm being attacked, then defend my base
	if (cpu_manager:GetCriticalSituation() > 0 or cpu_manager:GetCriticalThreat() > 500) then
		return "Defensive"
	end

	-- Check for an enemy
	local oEnemy = cpu_manager:FindCommonEnemyPlayer()
	if (oEnemy == nil) then
		return "Defensive"
	end
	
	-- If my force is at least 80% as strong than the other dude's, and I'm not busy defending, attack them!
	local iMyPower = cpu_manager:GetArmyStrength()
	local iEnemyPower = cpu_manager:GetArmyStrength(oEnemy)
	self.rating = iMyPower - iEnemyPower
	local iMinArmyPower = cpu_manager:GetTierLevel() * cpu_manager:MinArmyStrengthPerTier()
	if (iMyPower < iEnemyPower * 0.8 or iMyPower < iMinArmyPower) then
		return "Defensive"
	end
	
	-- Ready to attack
	return "Offensive"
end

function BuildBaseStrategy:DefensiveStance()

	aitrace("BuildController: Compute defensive stance...")
	
	-- Check stance
	if (self:CheckStance() == "Offensive") then
	
		-- Go to offensive mode
		aitrace("BuildController: Switch to offensive mode...")
		self:SetStatus( BuildBaseStrategy.Status.Offensive )
		self.military_stance = BuildBaseStrategy.OffensiveStance
		return
	end
end

function BuildBaseStrategy:OffensiveStance()

	aitrace("BuildController: Compute offensive stance...")

	-- Check stance
	if (self:CheckStance() == "Defensive") then

		-- Go to defensive mode
		aitrace("BuildController: Switch to defensive mode...")
		self:SetStatus( BuildBaseStrategy.Status.Defensive )
		self.military_stance = BuildBaseStrategy.DefensiveStance
		return
	end
	
	-- Init attack
	self:PostEvent(Strategy.Events.OnAttack)
end

-- Arkhan 11.2006: Virtual method to build more squad/support cap
function BuildBaseStrategy:EvaluateSquadCap()
	
end

-- Arkhan 10.2005: Calculates, if more squad cap is needed
function BuildBaseStrategy:CheckSquadCap(iMinRequisition, iMinPower)

	-- Check squad cap
	local iSquadCapTotalMax		= build_manager:GetSquadCapTotalMax()
	local iSquadCapLeft			= build_manager:GetSquadCapLeft()
	local iSquadCapCurrentMax	= self:GetCurrentSquadCap() + iSquadCapLeft
	if (iSquadCapLeft > self.info.squad_cap_threshold or iSquadCapCurrentMax >= iSquadCapTotalMax) then
		return false
	end
	
	-- Check requisition
	local iRequisition = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Requisition ) / self.m_iTechBreak
	local iPower = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Power ) / self.m_iTechBreak
	if (iRequisition < iMinRequisition or iPower < iMinPower) then
		self:SaveRessources(true, "Squad Cap")
		return false
	end
	
	return true
end

-- Arkhan 10.2005: Calculates, if more support cap is needed
function BuildBaseStrategy:CheckSupportCap(iMinRequisition, iMinPower)

	-- Check support cap only if we have a vehicle building
	if (self:GetBuildingCountByName(self:GetBuildingName("VehicleBuilding", true)) <= 0) then
		return false
	end

	-- Check squad cap
	local iSupportCapTotalMax	= build_manager:GetSupportCapTotalMax()
	local iSupportCapCurrentMax	= build_manager:GetSupportCapCurrentMax()
	local iSupportCapLeft		= build_manager:GetSupportCapLeft()
	if (iSupportCapLeft > self.info.support_cap_threshold or iSupportCapCurrentMax >= iSupportCapTotalMax) then
		return false
	end
	
	-- Check requisition
	local iRequisition = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Requisition ) / self.m_iTechBreak
	local iPower = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Power ) / self.m_iTechBreak
	if (iRequisition < iMinRequisition or iPower < iMinPower) then
		self:SaveRessources(true, "Support Cap")
		return false
	end
	
	return true
end

function BuildBaseStrategy:DevalueUnitByTier( unit_stats )
	-- This race does not devalue units!
	return 0
end

function BuildBaseStrategy:CountSquads(sUnitName, oFunctor)

	-- Check for a functor
	if (oFunctor == nil) then
	
		-- Use fast unit counting
		local iUnitID = cpu_manager.stats:GetSquadID(sUnitName)	
		return cpu_manager.player_stats:GetNumSquadsByBPID(iUnitID)
	end
	
	-- Use slow unit counting
	local iUnitCount = 0
	for oSquad in military_manager:GetSquads() do
	
		-- Check if unit is valid
		if (oSquad:IsValid()) then
		
			-- Check unit name and functor
			if (oSquad:GetSquadName() == sUnitName and oFunctor(oSquad)) then
				iUnitCount = iUnitCount + 1
			end
		end
	end
	return iUnitCount
end

function BuildBaseStrategy:DeepStrikeAndRallyGo()
        local vTargetPosAttack = AttackStrategy.m_vAttackPosition
        local vTargetPosDefend = DefendStrategy.m_vDefendPosition
        local vTargetPos = Vector3f(0,0,0)
        if (vTargetPosDefend.x ~= 0 or vTargetPosDefend.y ~= 0 or vTargetPosDefend.z ~= 0) then
        vTargetPos = vTargetPosDefend
        elseif (vTargetPosAttack.x ~= 0 or vTargetPosAttack.y ~= 0 or vTargetPosAttack.z ~= 0) then
        vTargetPos = vTargetPosAttack
        end

        if (vTargetPos.x ~= 0 or vTargetPos.y ~= 0 or vTargetPos.z ~= 0) then
          if g_iGMT == Strategy.RallyPoint then
    	     for build_channel in build_manager:GetBuildChannelAIs() do
                 if not cpu_manager:IsHQ(build_channel:GetBlueprintID()) and build_channel:ConstructionDone() and build_channel:IsBuilding()~=0 then
                    if cpu_manager.stats:GetUnitStatsFromBPID(build_channel:IsBuilding())~=nil then
		    build_channel:SetRallyPoint( vTargetPos )
                    end
                 end
	     end
          end
         for build_channel in build_manager:GetBuildChannelAIs() do

                       local name = build_channel:GetEntity()

			if (build_channel:CanDeepStrike() and cpu_manager:MilitaryDeepStrike(build_channel:GetBlueprintID())) then
	                  local oDeepStrikeBuilding = name:GetPosition()
                           	if (build_channel:CanOnlyDeepStrikeToEntity()) then
					
					-- Find someone who can summon
					local can_summon = function( squad_ai )
						return squad_ai:CanSummon()
					end

					local attacking_unit = cpu_manager:GetClosestSquad(attack_now_pos, 100, can_summon)
					if (attacking_unit) then
						build_channel:DoDeepStrikeToSquad( attacking_unit:GetSquad() )
					end
				else
					build_channel:DoDeepStrikeToPos(vTargetPos)
				end		
	
                        if (CpuManager:GetShortestPathingDistance(oDeepStrikeBuilding, vTargetPos, false)>100) then
	                   local oStrategicPost = cpu_manager:FindClosestPostToStructure(oDeepStrikeBuilding, false, 100)
                           if oStrategicPost ~= nil then
                            voStrategicPost = oStrategicPost

                                local vDeepStrikeBuilding = Vector3f()
                                local iBiasToEnemy = math.random(10, 20)

	                          -- Calculate direction vector
	                          riClosestDistance = math.sqrt(CpuManager:GetShortestPathingDistance(oDeepStrikeBuilding, vTargetPos, false))
	                          vDir = Vector3f(0, 0, 0)
	                          vDir.x = (vTargetPos.x - voStrategicPost.x) / riClosestDistance
	                          vDir.z = (vTargetPos.z - voStrategicPost.z) / riClosestDistance
	
	                          -- Add bias to enemy
	                          riClosestDistance = riClosestDistance + iBiasToEnemy
	                          vDeepStrikeBuilding.x = voStrategicPost.x + vDir.x * iBiasToEnemy
	                          vDeepStrikeBuilding.z = voStrategicPost.z + vDir.z * iBiasToEnemy

                                local vPosAttack  = vDeepStrikeBuilding
                                build_channel:DoDeepStrikeToPos(vPosAttack)
                           end
		        elseif (CpuManager:GetShortestPathingDistance(oDeepStrikeBuilding, vTargetPos, false)<100) then
					build_channel:DoDeepStrikeToPos(vTargetPos)
				end			
			end	
         end	
        else
         for build_channel in build_manager:GetBuildChannelAIs() do
                        if (build_channel:CanDeepStrike() and not build_channel:CanOnlyDeepStrikeToEntity()) then
                        local name = build_channel:GetEntity()
	                local oDeepStrikeBuilding = name:GetPosition()
				local pos = oDeepStrikeBuilding
 				pos.x = pos.x + math.random(-10, 10)
				pos.z = pos.z + math.random(-10, 10)
				build_channel:DoDeepStrikeToPos(pos)
                        end
         end	
        end
end

-- Arkhan 10.2005: Changed to fit the new build program concept
function BuildBaseStrategy:Update()

	aitrace("BuildBaseStrategy: Update...", true)

	-- Superclass
	Strategy.Update(self)

	-- Always want more strategic points
        if (self.post_builder < 2 and g_iGMT > 240) then
        self.post_builder = self.post_builder + 1
        end

	aitrace("BuildBaseStrategy: 1", true)

	  if (self:PlanCount( "Resource Plan" ) < self.post_builder) then
		self:AddPlan( ResourcePlan() )	
	  end

	-- Check my army strength
--	self.m_iArmyStrength = cpu_manager:GetArmyStrength()
--	aitrace("BuildController: Current army strength = "..tostring(self.m_iArmyStrength))

	aitrace("BuildBaseStrategy: 2", true)
	-- Set capture plans
        local level = cpu_manager.cpu_player:GetDifficultyLevel()
	local iCapturePlans = self.info.flag_capture
	if (cpu_manager:GetArmyStrength() > 2500) then
		iCapturePlans = iCapturePlans + 2
	end
        if (level == CpuPlayer.AD_Insane and g_iGMT<120 and cpu_manager.player_stats:GetPlayerRaceName() ~= "necron_race") then 
                iCapturePlans = iCapturePlans + 2  
        end
        if (level == CpuPlayer.AD_Advanced and g_iGMT<120 and cpu_manager.player_stats:GetPlayerRaceName() ~= "necron_race") then 
                iCapturePlans = iCapturePlans + 1  
        end
        if g_iGMT < 300 and cpu_manager.player_stats:GetPlayerRaceName() ~= "necron_race" then
		iCapturePlans = iCapturePlans + 4
        end
        if g_iGMT > 60 and cpu_manager.player_stats:GetPlayerRaceName() == "necron_race" then
		iCapturePlans = iCapturePlans + 2
        end
	aitrace("BuildBaseStrategy: 3", true)
        if (g_iGMT > 20) then
	 if (self:PlanCount( "Capture Plan" ) < iCapturePlans) then
		self:AddPlan( CapturePlan( cpu_manager.start_pos ) )	
	 end
        end

	aitrace("BuildBaseStrategy: 4", true)

	-- Check current tier
	self:UpdateTierLevel()
	aitrace("BuildBaseStrategy: 5", true)
        self:CheckTech()
        self:CheckTechBufer()

	-- Build buildings, research and addons
	aitrace("BuildBaseStrategy: 6", true)
	self:ComputeBuildProgram()
	aitrace("BuildBaseStrategy: 6.1", true)
        self:DeepStrikeAndRallyGo()

	-- Update HQ count
	aitrace("BuildBaseStrategy: 7", true)
	self.num_hq = self:GetBuildingCountByName(self:GetBuildingName("HQ"))
	
        if self.techongo == true then
        self.m_bSpendMoney = true
        end

	local iRequisition = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Requisition )
	local iPower = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Power )
	-- Additional builders at higher tiers
	if (self.tierLevel == 1 and (iRequisition > 500 and iPower > 1000)) then
        self.m_bSpendMoney = true
        end
	if (self.tierLevel == 2 and (iRequisition > 1000 and iPower > 1500)) then
        self.m_bSpendMoney = true
        end
	if (self.tierLevel == 3 and (iRequisition > 1500 and iPower > 2000)) then
        self.m_bSpendMoney = true
        end
	if (self.tierLevel == 4 and (iRequisition > 2500 and iPower > 3000) or (self.tierLevel == 4 and cpu_manager.player_stats:GetPlayerRaceName() == "inquisition_daemonhunt_race")) then
        self.m_bSpendMoney = true
        end
	if (self.tierLevel == 5) then
        self.m_bSpendMoney = true
        end

	aitrace("BuildBaseStrategy: 8", true)
	-- Check if we need more cap !
	  if (not cpu_manager:HQThreat() and self.m_bSpendMoney) then 
		self:EvaluateSquadCap()
	  end
	aitrace("BuildBaseStrategy: 9", true)
	-- Check last update
	if (g_iGMT > self.m_iNextUpdate) then

	        -- Build LP's if possible (Necessary because of DC 1.2 bug)
		local sPostName = self:GetBuildingName("ListeningPost")
		if (sPostName ~= nil and (iRequisition > 40) or (cpu_manager.player_stats:GetPlayerRaceName() == "necron_race")) then
		
			-- Check if post plan exist
			local iID = cpu_manager.stats:GetBuildingID(sPostName)
			if (self:PlanCount("Build Building Plan", iID)<1) then
			
				-- Try to build post
		        local tBuildType = CpuBuildType()
		        tBuildType.btype = CpuPrerequisites.BT_Building
		        tBuildType.name = sPostName
		        if (self:TryBuild( tBuildType )) then
		            aitrace("BuildController: Dynamic build of "..tBuildType.name)
		        end
			end
		end

                self.m_iNextUpdate = g_iGMT + 2
	end
	aitrace("BuildBaseStrategy: 10", true)
	self:DoBuildUnits()


          if g_iGMT > (CpuManager.ForceTech.StartTier1-0.3)*60 then
	aitrace("BuildBaseStrategy: 11", true)
		-- Build generators
		self:DoBuildGenerators()
	  end

	if (g_iGMT > self.m_iNextUpdateBuilding) then
	aitrace("BuildBaseStrategy: 12", true)
                -- Race strategy and tactic
                self:BuildStrategyTactic()

		-- Finish buildings
	aitrace("BuildBaseStrategy: 13", true)
		self:FinishBuildings()	

		-- Race specific builds
	aitrace("BuildBaseStrategy: 14", true)
		self:BuildFlexible()

                self.m_iNextUpdateBuilding = g_iGMT + 5
	end


       	aitrace("BuildBaseStrategy: 15", true)
	-- Either defend or check if I should attack
	self.military_stance( self )
end

function BuildBaseStrategy:BuildHighSpeedPriority()

end

-- Arkhan 10.2005: Abstract method for race specific builds
function BuildBaseStrategy:BuildFlexible()
	-- Should be empty
end

function BuildBaseStrategy:BuildStrategyTactic()
	-- Should be empty
end

function BuildBaseStrategy:FinishBuildings() 

	aitrace("BuildController: Finish buildings...")

	-- Try to finish a building that wasn't finished (probably because the AI was reset)
	local iBuildingID = build_manager:FindAnyUnfinishedBuildings()
	if (iBuildingID ~= 0) then
	
		-- First see if I'm already trying to finish this
		if (self:PlanExists("Build Building Plan", iBuildingID)) then
			return
		end
	
		-- Check for auto-construct buildings
		if (cpu_manager:AutoConstructBuildings()) then
	
			-- Get building
			local oBuilding = build_manager:FindUnfinishedBuilding(iBuildingID)
			if (not oBuilding) then
				return
			end
			
			-- Get building AI
			local oBuildingAI = military_manager:GetBaseFromID(oBuilding:GetID())
			if (oBuildingAI == nil) then
				return
			end
			
			-- Check health
			if (oBuildingAI:GetHealthPercentage() > 0.2) then
				return
			end
		end
		
		-- Build it!
		self:AddPlan(BuildBuildingPlan(iBuildingID, cpu_manager.start_pos))
	end
end

-- Arkhan 10.2005: Modified to allow bigger generators in tier2
function BuildBaseStrategy:DoBuildGenerators()

	aitrace("BuildController: Check generators...")

	local numGenerators = resource_manager:GetNumOwnedPowerGenerators()
        local iRequisition = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Requisition )

	if (self.tierLevel==1) and iRequisition<400 then
         return
        end

	-- Check requisition
	if (iRequisition < 300 and self.tierLevel<2) then
		return
	end

	-- Check power
	local iPower = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Power )
	if (iPower > 300 and g_iGMT < 5*60) then
		return
	end
	
	-- Get maximum amount of generators
	local max_gen = self.num_hq * 6
	
	-- We don't want more than this even if we have multiple HQs
	if (max_gen > self.m_iMaxGenerators) then
		max_gen = self.m_iMaxGenerators
	end

	-- Build if we are below min power per tier
	if ((self.tierLevel == 1 and iPower > 300 and self.info.req_reserve > 0) or
		(self.tierLevel == 1 and iPower > 600 and self.info.req_reserve <= 0) or
		(self.tierLevel == 2 and iPower > 900) or
		(self.tierLevel >= 3 and iPower > 1200)) and iRequisition < 500 then
		
		return
	end

	local iBiggerGeneratorID = cpu_manager.stats:GetBuildingID(self:GetBuildingName("BiggerGenerator"))
	-- Try to build a bigger generator
--[[	aitrace("BuildController: Trying to build bigger generator")
	if (self:PlanExists("Build Building Plan", iBiggerGeneratorID)) then
		return
	end]]

--[[	-- Check if any generators are in production
	for oBuildChannel in build_manager:GetBuildChannelAIs() do

		-- Check building ID
		if (oBuildChannel:GetBlueprintID() == iGeneratorID and not oBuildChannel:ConstructionDone()) then
			return
		end
	end]]

	-- Check build plans for generators
	--[[local iGeneratorID = cpu_manager.stats:GetBuildingID(self:GetBuildingName("Generator"))
	local iBiggerGeneratorID = cpu_manager.stats:GetBuildingID(self:GetBuildingName("BiggerGenerator"))
	if (self:PlanExists("Build Building Plan", iGeneratorID) or self:PlanExists("Build Building Plan", iBiggerGeneratorID)) then
		return
	end]]	 

	-- Update where the free slag heaps are
	resource_manager:UpdateFreeSlagHeaps(iBiggerGeneratorID)
	
	-- Look for the closest generator
	local base_pos = cpu_manager.start_pos 
	local slag_table = {}
	
	for slag_heap in resource_manager:GetSlagHeaps() do
	   
		local slag_pos = slag_heap:GetPosition()					
		if (not cpu_manager.terrain_analyzer:HasThreat( slag_pos, 35 )) then
		  
			-- Find available engineer
			local functor = function( squad_ai )
							 
				local squad_pos = squad_ai:GetPosition()
				return (squad_ai:IsEngineer() and squad_ai:CanBuild(iBiggerGeneratorID) == SquadAI.CANBUILD_Ok and
						not cpu_manager:HasThreatOnPath( squad_pos, slag_pos, 35 ))
			end
			
			local engineer = cpu_manager:GetClosestUnlockedSquad( slag_pos, 500, functor )
			if (engineer ~= nil) then
				aitrace("BuildController: Build bigger generator pathing check...")
				local dist = cpu_manager:GetShortestPathingDistance( base_pos, slag_pos, true )
				local max_dist = 200 + self.tierLevel * 60
				--only close slag heaps at low tier levels
				if dist > 0 and dist <= max_dist then
					local can_build = engineer:CanBuildAt(iBiggerGeneratorID, slag_pos )
					table.insert( slag_table, {slag_pos, engineer, dist, can_build} ) 
				end
			end
		end
	end
	
	local num_items = table.getn ( slag_table )
	
	-- Multiple entries, we have to sort by distance
	if (num_items > 1) then
		sortfunc = function( item1, item2 )					
			return item1[3] < item2[3]
		end
		table.sort( slag_table, sortfunc )
	end

	if (num_items > 0) then	 
	
		if (slag_table[1][4]) then
	
			-- Add the plan to build, can_build is true
			aitrace("BuildManager: Dynamic build of bigger generator at "..tostring(slag_table[1][1].x)..", "..tostring(slag_table[1][1].z))
			self:AddPlan( BuildBuildingPlan(iBiggerGeneratorID, slag_table[1][1]) )
		else
	  
			-- Send engineer to slag position
			if (not cpu_manager:JumpBuilder( slag_table[1][2], slag_table[1][1] )) then
				cpu_manager:DoMove( slag_table[1][2], slag_table[1][1], false, "Go to bigger generator")
			end
		end
		
	elseif (numGenerators < max_gen) then

		-- Build basic generator
		local build_type = CpuBuildType()
		build_type.btype = CpuPrerequisites.BT_Building
		build_type.name = self:GetBuildingName("Generator")
		if (self:TryBuild( build_type )) then
			aitrace("BuildController: Dynamic build of a generator")
		end
	end
end

function BuildBaseStrategy:CalculateSquadDemand( unit_id, unit_stats )

	--check if this squad type is locked out
	if not build_manager:CanBuildSquad( unit_id ) then
		return VALUE_LOCK_BUILD
	end

	local prereq = CpuPrerequisites2( cpu_manager.cpu_player, unit_stats:GetSquadName(), CpuPrerequisites.BT_Squad )

	--check if we can even build it, ever
	if prereq:CannotFulfillPrereqs() then
		return VALUE_NEVER_BUILD
	end
   
	local squad_name = unit_stats:GetSquadName()
	local squad_count = self:CountSquads(squad_name)
	local demand = 0
	local deval = 0
	
	-- Modify for certain squads we like/dislike
	local squad_mod = self:ModifySquadDemand(unit_id)
	--aitrace ("    "..string.format("%-30.30s",unit_stats:GetSquadName()))
	
	-- get class demand
	local class_demand = self:GetClassDemand( unit_stats:GetClass() )
	--aitrace ("      class demand: "..string.format("%7.2f",class_demand))
--[[	if class_demand < 0 then
		--inverse scale for bigger units
		class_demand = ( 10 - unit_stats:GetClassRating() ) * class_demand
	else
		class_demand = class_demand
	end]]
	if (class_demand < 0.0) then
		class_demand = -(1.0 / class_demand)
	end
	class_demand = unit_stats:GetClassRating() * (class_demand + 1.0)
  
	-- get standard effectiveness demand
	local effect_demand = 0	
	for class = 0, UnitStatsAI.UC_Count - 1 do
	  
		effect_demand = effect_demand + 
			self:GetEffectivenessDemand( class ) * unit_stats:GetEffectivenessRating( class )
		--aitrace ("      Class: "..string.format("%02.0f",class).." General Eff Dmd: "..string.format("%06.2f",self:GetEffectivenessDemand( class ))..
			--" Unit Eff Rat: "..string.format("%06.2f",unit_stats:GetEffectivenessRating( class )))
		--aitrace ("      Cumulative eff dmd : "..string.format("%08.2f",effect_demand))
	end
	--aitrace ("      effect demand: "..string.format("%7.2f",effect_demand))
	
	--effect_demand = effect_demand / UnitStatsAI.UC_Count commented by Kaiser Soze: reduces too much the effectiveness
	if effect_demand > 0 then
   		effect_demand = math.sqrt(effect_demand)
 	else
   		effect_demand = effect_demand / 3
   	end	
 	
   	--depress rating according to tier
   	--we depress according squad_mod
	if squad_mod == 0 then
		deval = VALUE_NO_ATTACH
	else --we depress accoring to standard race specific values
		deval = self:DevalueUnitByTier( unit_stats )
	end
	demand = class_demand + effect_demand
	if demand < 0 then
   		demand = 0
   	end	
	demand = demand + deval
	
--	aitrace ("      "..string.format("%-30.30s",squad_name).." Total Demand: "..string.format("%6.2f",demand))
   
	--if I can't build it right now because I don't have the money
	--figure out how long it'll take, and factor that in
--[[	local power_needed = unit_stats:GetCost( ResourceAmount.RT_Power ) - 
		  resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Power )
	local req_needed = unit_stats:GetCost( ResourceAmount.RT_Requisition ) - 
		  resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Requisition )
	local req_weight = 0
	local power_weight = 0
	local ticks_per_second = 8
	
	if power_needed > 0 then
		  
	   --rate is measured in rate per minute. we want it per second
	   local power_rate = resource_manager:GetResourceRate( ResourceAmount.RT_Power ) / 60
	   
	   --if no power coming in, don't try to build stuff with power prereqs!
	   if power_rate == 0 then
		  return VALUE_RESOURCE_RATE
	   else
		  
		  power_weight = power_needed / power_rate		 
	   end	  
	end
	
	if req_needed > 0 then
	   
	   --rate is measured in rate per minute. we want it per second
	   local req_rate = resource_manager:GetResourceRate( ResourceAmount.RT_Requisition ) / 60
	   
	   if req_rate == 0 then
		  return VALUE_RESOURCE_RATE
	   else
		  req_weight = req_needed / req_rate
	   end
	end
	
	--how many seconds before I can build this thing
	local resource_time = 0
	if power_weight > req_weight then
	   resource_time = power_weight
	else
	   resource_time = req_weight
	end
	
	--check time cap
	if resource_time > 180 then
	   return VALUE_BUILD_TIME
	end
   
	-- Arkhan 11.2005: Check ressources
	local iRequisition = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Requisition )
	local iPower = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Power )

	-- Arkhan 11.2005: Check squad and support cap
	local iSquadCap	  = self:GetCurrentSquadCap()
	local iSupportCap = build_manager:GetSupportCapCurrentMax() - build_manager:GetSupportCapLeft()
   
	-- Arkhan 11.2005: Force the build of vehicles if power is available and requisition rare
	if (iSquadCap >= 6) then
		if (unit_stats:GetSupportCapReq() > 0) then
			demand = demand * 2
		end
	end
	
	-- Arkhan 01.2006: Force the build of squads if requisition is available and power rare
	if (iSupportCap >= 6) then
		if (unit_stats:GetSquadCapReq() > 0) then
			demand = demand * 2
		end
	end]]

	-- Arkhan 12.2005: Decrease squad demand for every already existing unit of this type by 20%, to increase unit diversity
	demand = math.max(demand * (100 - 20 * squad_count) / 100, demand / 2)   
--	aitrace ("      "..string.format("%-30.30s",squad_name).." Final Demand: "..string.format("%6.2f",demand))
	return demand   
end

-- Arkhan 03.2006: Abstract method to modify squad demand
function BuildBaseStrategy:ModifySquadDemand(iUnitID)
	return 50
end

function BuildBaseStrategy:BuildUnits()
		
	-- Try to build units for now (for defense while teching up)
	local hightableitem = self:GetHighestDemandedSquad(true)
	local iSquadCap			= self:GetCurrentSquadCap()
	local iSupportCapLeft	= build_manager:GetSupportCapLeft()
	local iSupportCap		= build_manager:GetSupportCapCurrentMax() - iSupportCapLeft

--[[     1       iUnitID,
          2      iHighestDemand,
          3      iUnitIDTANK,
           4     iHighestDemandTANK,
           5     iUnitIDNoLimit,
            6    iHighestDemandNoLimit,
            7    iUnitIDNoLimitTANK,
             8   iHighestDemandNoLimitTANK]]

	if (hightableitem.iUnitIDTANK ~= nil) then
	
		local build_type = CpuBuildType()
		build_type.btype = CpuPrerequisites.BT_Squad
		build_type.name = cpu_manager.stats:GetSquadName( hightableitem.iUnitIDTANK )

		aitrace( "Spawn NOW Tank: "..build_type.name )
		self:TryBuild( build_type )
	end

	if (hightableitem.iUnitIDNoLimitTANK ~= nil) and iSupportCap>10 then
	
		local build_type = CpuBuildType()
		build_type.btype = CpuPrerequisites.BT_Squad
		build_type.name = cpu_manager.stats:GetSquadName( hightableitem.iUnitIDNoLimitTANK )

		aitrace( "Spawn NOW NoLimit Tank: "..build_type.name )
		self:TryBuild( build_type )
	end

	if (hightableitem.iUnitID ~=nil) then
	
		local build_type = CpuBuildType()
		build_type.btype = CpuPrerequisites.BT_Squad
		build_type.name = cpu_manager.stats:GetSquadName( hightableitem.iUnitID )

		aitrace( "Spawn NOW: "..build_type.name )
		self:TryBuild( build_type )
	end

	if (hightableitem.iUnitIDNoLimit ~= nil) and iSquadCap>12 then
	
		local build_type = CpuBuildType()
		build_type.btype = CpuPrerequisites.BT_Squad
		build_type.name = cpu_manager.stats:GetSquadName( hightableitem.iUnitIDNoLimit )

		aitrace( "Spawn NOW NoLimit: "..build_type.name )
		self:TryBuild( build_type )
	end
end

function BuildBaseStrategy:DoBuildUnits()
	aitrace("BuildController: Building units...")

	self:CalculateEngineerDemand()
	self:CalculateDetectorDemand()

	-- Don't build units if a building, research or addon is more important
	if (not self.m_bSpendMoney and not self.techongo) then
		aitrace("BuildController: No ressources for units available")
		return
	end
        
        if Strategy.NextUpdateUnitDoProd==0 then
        self.unitupdate_enemy = cpu_manager:FindClosestEnemyPlayer()
        end

        if self.unitupdate_enemy~=nil then
           if self.unitupdate_enemy:IsPlayerDead() then
                self.unitupdate_enemy = cpu_manager:FindClosestEnemyPlayer()
           end
        end

        if g_iGMT <= 8 then
          if Strategy.NextUpdateUnitDoProd==g_iGMT then
             Strategy.NextUpdateUnitDoProd=0
          end
          return
        end

	--check if using designer strategy. If so, don't build my own units
	if cpu_manager:IsUsingDesignerPreference() then
		aitrace("using designer preferences")
		return
	end

	if Strategy.NextUpdateUnitDoProd == 8 then
	--calculate wants for units
	  if self.unitupdate_enemy ~= nil then
		self:ResetDemand(1)
		local player_id = self.unitupdate_enemy:GetPlayerID()
		self:CalculateAll( player_id )
	  end
	elseif Strategy.NextUpdateUnitDoProd == 22 then
	  if self.unitupdate_enemy ~= nil then
	    self:ResetDemand(2) 
	    for unit_stats in cpu_manager.stats:GetUnitStats( cpu_manager.cpu_player:GetPlayerRace() ) do
	   
	     local unit_id = unit_stats:GetID()
	     local demand = self:CalculateSquadDemand( unit_id, unit_stats )
	     self:SetSquadDemand( unit_id, demand )	
	    end  
	  end
        end
        self:BuildUnits()	
        Strategy.NextUpdateUnitDoProd = Strategy.NextUpdateUnitDoProd + 1	
end

--Corsix Added
function BuildBaseStrategy:AddOnNotify( addon_id, notify_code , build_channel)
	aitrace("this race does not have an addon notify!")
end
--End

function BuildBaseStrategy:HQEmergency()
	return (self.num_hq <= 0 and military_manager:GetNumEngineers() >= 1)
end

-- Arkhan 10.2005: Compute build programs
function BuildBaseStrategy:ComputeBuildProgram()

	aitrace("BuildController: Compute build program...")

	-- Check ressources
	local iRequisition = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Requisition ) / self.m_iTechBreak
	local iPower = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Power ) / self.m_iTechBreak

	-- Check squad and support cap
	local iSquadCapLeft		= self:GetSquadCapLeft()
	local iSquadCap			= self:GetCurrentSquadCap()
	local iSupportCapLeft	= build_manager:GetSupportCapLeft()
	local iSupportCap		= build_manager:GetSupportCapCurrentMax() - iSupportCapLeft
	
	-- Get current tier
	local iTier = self:GetTierLevel()
	aitrace("BuildController: Current tier = "..tostring(iTier))
	
	-- Get current army strength
	local iArmyStrength = cpu_manager:GetArmyStrength()
	aitrace("BuildController: Current army strength = "..tostring(iArmyStrength))
	
	-- Check if we have a builder
	local iBuilders = military_manager:GetNumEngineers()
	
	-- Check for massive battles mode
	local fArmyCapModifier = 1.0
	if (CpuManager.AISettings.bMassiveBattlesMode and g_fMassiveBattlesModifier ~= nil) then
		fArmyCapModifier = g_fMassiveBattlesModifier
	end
			
	-- Reset squad limits (for the moment)
	local iIndex = 1
	for iLoop1 in self.info.SquadLimits do
		if (self.m_iSquadLimit == iIndex) then
			for iLoop2 in self.info.SquadLimits[iLoop1] do
				build_manager:SetSquadLimit(iLoop2, math.floor(self.info.SquadLimits[iLoop1][iLoop2] * fArmyCapModifier + 0.5))
			end
			break
		end
		iIndex = iIndex + 1
	end

	-- Create list of build channels
	self.m_aBuildChannels = {}
	for oBuildChannel in build_manager:GetBuildChannelAIs() do
	
		-- Only add complete build channels
		if (oBuildChannel:ConstructionDone()) then
			table.insert(self.m_aBuildChannels, { oBuildChannel, oBuildChannel:GetBlueprintID() })
		end
	end
	
	-- HQ emergency check
	if (self:HQEmergency()) then
		self.m_bSpendMoney = false
		Tactic.Options.can_reinforce = false
	else
		self.m_bSpendMoney = true
		Tactic.Options.can_reinforce = self:CheckReinforce()
	end
	aitrace("BuildController: 1", true)
	-- Check for force teching
	local bForceTech = false
	if (self:ForceTech()) then
		aitrace("BuildController: 1.1", true)
		-- Check HQ threat
		if (cpu_manager:GetCriticalSituation() <= 0) then
			aitrace("BuildController: 1.2", true)
			-- Force teching
			aitrace("BuildController: Force teching!!!")
			bForceTech = true
	   		Tactic.Options.can_reinforce = false
	   		self.m_bSpendMoney = false
		end
              aitrace("BuildController: 1.3", true)
              if cpu_manager:GetCriticalSituation() > 0 then
              self.m_bSpendMoney = true
              end
              aitrace("BuildController: 1.4", true)
                if self.techongo == true then
                   self.m_bSpendMoney = true
                end
	end
        aitrace("BuildController: 1.4.1", true)
	-- Check if we have to abort a rush program
	if (self.m_iPrepareRush > 0 and cpu_manager:GetCriticalSituation() > 0) then
              aitrace("BuildController: 1.5", true)
    	-- Abort rush
    	aitrace("ABORT RUSH")
		self.m_iPrepareRush = 0
		self.m_iFinishedRush = 4
		
	    -- Switch to standard build program
	    BuildBaseStrategy.iBuildProgram = 1
	end
              aitrace("BuildController: 1.6", true)		
	-- Create building list and validate start point
	self.m_aBuildings = {}
	self.m_aListeningPosts = {}
	local iHQID = cpu_manager.stats:GetBuildingID(self:GetBuildingName("HQ"))
	local vHQPos = nil
	local bUpdateStartPoint = true
	local iClosestHQDistance = sqr(1000)
	for oBuilding in military_manager:GetBases() do
	              aitrace("BuildController: 1.7", true)
		-- Check for valid building
		if (oBuilding:IsValid()) then
		
			-- Get blueprint ID
			local iBlueprintID = oBuilding:GetBlueprintID()
		              
			-- Add to building or post list
			if (oBuilding:IsListeningPost()) then
				table.insert(self.m_aListeningPosts, { oBuilding, iBlueprintID, oBuilding:IsConstructionDone() })
			else
	  			table.insert(self.m_aBuildings, { oBuilding, iBlueprintID, oBuilding:IsConstructionDone() })
	  		end
	  		
	  		-- Get position
			local vPos = oBuilding:GetPosition()
		
			-- Check for buildings in range of current start point
			local iDistance = distance_sqr(vPos, cpu_manager.start_pos)
			if (iDistance < sqr(35)) then
				bUpdateStartPoint = false
			end
		
			-- Check for HQ building
			if (iBlueprintID == iHQID and iDistance < iClosestHQDistance) then
				vHQPos = vPos
				iClosestHQDistance = iDistance
			end
		end
	end
	aitrace("BuildController: 2", true)

	-- Update start point if necessary
	if (bUpdateStartPoint and vHQPos ~= nil) then
	
		-- Validate position
		aitrace("CpuManager: Reset start point")
		cpu_manager.start_pos = vHQPos
	end
	
	-- Make sure we've enough req in tier 1 to build posts
	if (g_iGMT <= 120) then
		iRequisition = iRequisition - 100
	end
	
--[[	-- Check if we are building a bigger generator
	local iBiggerGeneratorID = cpu_manager.stats:GetBuildingID(self:GetBuildingName("BiggerGenerator"))
	local oBiggerGeneratorPlan = self:GetPlan("Build Building Plan", iBiggerGeneratorID)
	if (oBiggerGeneratorPlan ~= nil and not oBiggerGeneratorPlan.started_building and not self:HasResourcesForBiggerGenerator(iRequisition, iPower)) then
		self:SaveRessources(true)
		return
	end]]

	-- Compute build program
	local aTurretPosition = {}
	local bSaveRessources = true
	local bBuildUnits = true
	local iBuildProgramSize = table.getn(self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram])
	aitrace("BuildController: 3", true)
	for iLoop1 = 1, iBuildProgramSize do

		--print ( "Max "..tostring(iBuildProgramSize).." Loop "..tostring(iLoop1) )
		--print ( "Before "..self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][6].." - "..self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][7] ) 
		-- Extract object data
		local iMinTier			= self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][1]
		local iMinRequisition	= self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][2]
		local iMinPower			= self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][3]
		local iMinArmyStrength	= self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][4]
		local iCount			= self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][5]
		local sType				= self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][6]
		local sName				= self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][7]
		--print ( "After "..self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][6].." - "..self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][7] ) 
		
		-- dark40k 10.2008 -- 8th parameter added true if to be used only for this tier (was already the case for sType="Unit")
		local bSingleTier		= self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][8]
		local iID				= 0
		
		-- Modify the army strength
		if (self.info.ArmyStrengthModifier ~= nil) then
			iMinArmyStrength = iMinArmyStrength * self.info.ArmyStrengthModifier
		end
		
		-- If min requisition is 0, then set it to -100 to avoid problems
		if (iMinRequisition == 0) then
			iMinRequisition = -100
		end

		-- If min power is 0, then set it to -100 to avoid problems
		if (iMinPower == 0) then
			iMinPower = -100
		end
				
		-- Check how many instances exist
		local iCurrentInstances = 0
		
		-- luxury buildings
		local bIsLuxury = false

		-- dark40k 10.2008 : no creation if wrong tier and singletier set
		-- added first test to check Tier level
		if (iTier~=iMinTier) and bSingleTier then
			iCount = 0
		elseif (sType == "Building") then

			-- Check for turret but not ork banner
			if (sName ~= "ork_waagh_banner" and sName == self:GetBuildingName("Turret")) then
				
				bIsLuxury = true
				-- Check special modes and HQ threat
				if (not CpuManager.AISettings.bTurrets or cpu_manager:HQThreat()) then
					iCount = 0
				elseif (CpuManager.AISettings.bFortressMode) then
					iCount = math.min(iCount * 2, math.max(iCount, 6))
				end
			end
			
			-- Check for mine
			if (sName == self:GetBuildingName("Mine")) then
				
				bIsLuxary = true
				-- Check special modes
				if (not CpuManager.AISettings.bMines or cpu_manager:HQThreat()) then
					iCount = 0
				elseif (CpuManager.AISettings.bFortressMode) then
					iCount = math.min(iCount * 2, math.max(iCount, 6))
				end
			end

			-- Build building
			if (iCount > 0) then
			
				-- Get building ID
				iID = cpu_manager.stats:GetBuildingID(sName)
				
				-- Check building list for current building
				iCurrentInstances = self:GetBuildingCountByBPID(iID, false)
				
				-- Check build plans for current building
				local oBuildPlan = self:GetPlan("Build Building Plan", iID)
				if (oBuildPlan ~= nil) and self:PlanCount("Build Building Plan", iID) == iCount then
				
					-- Check if building was not started, yet
					if (not oBuildPlan.started_building and (iRequisition < iMinRequisition + 5 or iPower < iMinPower + 5)) then
						self:SaveRessources(bSaveRessources)
						return
					end
					
					-- Don't build more than two buildings of the same type at the same time
--					if (cpu_manager:AutoConstructBuildings()) then
--						iCurrentInstances = iCount
--					end
				end
			end
			
		elseif (sType == "Research") then
		
			-- Get research ID
			iID = cpu_manager.stats:GetResearchID(sName)
			
			-- Check if research exists
			if (cpu_manager.cpu_player:IsResearchComplete(sName)) then
				iCurrentInstances = iCurrentInstances + 1
			end
			
			-- Check if research plan exists
			local oBuildPlan = self:GetPlan("Build Research Plan", iID)
			if (oBuildPlan ~= nil) then
			
				-- Check if research was not started, yet
				if (not oBuildPlan.started_building and (iRequisition < iMinRequisition + 5 or iPower < iMinPower + 5)) then
					self:SaveRessources(bSaveRessources)
					return
				end
				iCurrentInstances = iCount
			end
			
		elseif (sType == "Addon") then
		
			-- Get addon ID
			iID = cpu_manager.stats:GetAddOnID(sName)
			
			-- Check existing addons
			local sAddonBuilding = self:GetAddonBuilding(sName)
			local iBuildingID = cpu_manager.stats:GetBuildingID(sAddonBuilding)
			local iBuildingCount = 0
			for iLoop2 in self.m_aBuildChannels do
			
				-- Check for addon building
				if (self.m_aBuildChannels[iLoop2][2] == iBuildingID) then
					iBuildingCount = iBuildingCount + 1
					if (self.m_aBuildChannels[iLoop2][1]:CanAddToQueue(BuildChannelAI.PQ_AddOn, iID) ~= BuildChannelAI.CANBUILD_Ok) then
						iCurrentInstances = iCurrentInstances + 1
					end
				end
			end
						
			-- Check HQ tier addon 1
			if (self:IsTierAddon(sName, 2) and not self.m_bHQAddon1) then
				iCurrentInstances = 0
				
			-- Check HQ tier addon 2
			elseif (self:IsTierAddon(sName, 3) and not self.m_bHQAddon2) then
				iCurrentInstances = 0
			end
			
	  		-- Calculate demand (one minimum)
			iCount = math.max(math.floor(iCount * iBuildingCount / 100), 1)
			
			-- Check if addon plan exists
			local oBuildPlan = self:GetPlan("Build AddOn Plan", iID)
			if (oBuildPlan ~= nil) then
			
				-- Check if addon was not started, yet
				if (not oBuildPlan.started_building and (iRequisition < iMinRequisition + 5 or iPower < iMinPower + 5)) then
					self:SaveRessources(bSaveRessources)
					return
				end
				iCurrentInstances = iCount
			end

		elseif (sType == "TurretAddon") then
		
			-- Get addon ID
			iID = cpu_manager.stats:GetAddOnID(sName)
			
			-- Check existing addons
			local sAddonBuilding = self:GetAddonBuilding(sName)
			local iTurretID = cpu_manager.stats:GetBuildingID(sAddonBuilding)
			local iTurretCount = 0
			aTurretPositions = {}
			for iLoop2 in self.m_aBuildChannels do
			
				-- Check for addon building
				if (self.m_aBuildChannels[iLoop2][2] == iTurretID) then
					iTurretCount = iTurretCount + 1
					if (self.m_aBuildChannels[iLoop2][1]:CanAddToQueue(BuildChannelAI.PQ_AddOn, iID) ~= BuildChannelAI.CANBUILD_Ok) then
						iCurrentInstances = iCurrentInstances + 1
						aTurretPositions[iCurrentInstances] = self.m_aBuildChannels[iLoop2][1]:GetEntity():GetPosition()
					end
				end
			end
			
			-- Check for fortress mode
			if (CpuManager.AISettings.bFortressMode and sAddonBuilding == self:GetBuildingName("Turret")) then
				iCount = math.max(iCount, 50)
			end
			
	  		-- Calculate demand (one minimum)
			iCount = math.max(math.floor(iCount * iTurretCount / 100), 1)
			
			-- Check if addon plan exists
			local oBuildPlan = self:GetPlan("Build NotifiedAddOn Plan", iID)
			if (oBuildPlan ~= nil) then
			
				-- Check if turret addon was not started, yet
				if (not oBuildPlan.started_building and (iRequisition < iMinRequisition + 5 or iPower < iMinPower + 5)) then
					self:SaveRessources(bSaveRessources)
					return
				end
				iCurrentInstances = iCount
			end
			
	  	elseif (sType == "Unit") then
	  	
	  		-- Check tier level, squad and support cap
	  		local iUnitSquadCap, iUnitSupportCap = self:GetUnitStats(sName)
	  		if (iTier == iMinTier and iSquadCapLeft >= iUnitSquadCap and iSupportCapLeft >= iUnitSupportCap and bBuildUnits) and ((not bForceTech or self.techongo) or iRequisition > 1500 and iPower > 1500) then
	  		
				-- Get unit ID
				iID = cpu_manager.stats:GetSquadID(sName)
		  		
				-- Check how many units we have of the current type
				iCurrentInstances = self:CountSquads(sName)
				
				-- Check unit count
				if (iCurrentInstances < iCount) then
				
					-- Don't build dynamic units in harassing time(Buildorder)
					if (g_iGMT < DefendChokePointPlan.HarassingTime * 60) then
						self.m_bSpendMoney = false
					end
					
					-- Keep building order in first 2 minutes
					if (g_iGMT < 30) then
						bBuildUnits = false
					end
				end
				
				-- Check if a plan exists for the current unit
				local oBuildPlan = self:GetPlan("Build Unit Plan", iID)
				if (oBuildPlan ~= nil) and self:PlanCount("Build Unit Plan", iID) == iCount then
					
					-- Check if unit was not started, yet
					if (not oBuildPlan.started_building and (iRequisition < iMinRequisition + 5 or iPower < iMinPower + 5)) then
						self:SaveRessources(bSaveRessources)
						return
					end
					iCurrentInstances = iCount
				end
		  	else
		  	
				-- Remove obsolete unit entries
				-- CAN CRASH ! Not sure why 
				-- if (iTier > iMinTier) then
				--	print ( "Removing "..self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][6].." - "..self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram][iLoop1][7] ) 
				--	table.remove(self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram], iLoop1)
				--	iBuildProgramSize = iBuildProgramSize - 1
				-- end
		  		iCount = 0
	  		end
	  		
	  	elseif (sType == "Rush") then
	  	
	  		-- Check if rush was already finished
	  		local bRestrictReinforcing = (iCount > 0)
	  		iCount = 0
	  		if (self.m_iFinishedRush < iMinTier) then
	  		
	  			-- Check tier level
	  			if (iMinTier >= iTier) then
	  			
	  				-- Check rush state
		  			if (sName == "Prepare") then
		  			
		  				-- Prepare rush
		  				if (self.m_iPrepareRush < iMinTier) then	  				
		  					aitrace("BuildController: Prepare tier"..tostring(iMinTier).." rush")
		  					self.m_iPrepareRush = iMinTier
		  				end
		  				
				  		-- Restrict unit building
			  			self.m_bSpendMoney = false
			  			
			  			-- Restrict reinforcing if count is greater than zero
			  			if (bRestrictReinforcing) then
			  				Tactic.Options.can_reinforce = false
			  			end
		  			else
		  			
						-- Wait until we've reached the required army strength
						if (iArmyStrength < iMinArmyStrength) then
							Tactic.Options.can_reinforce = true
							return
						end
			
						-- Unleash rush
						aitrace("BuildController: Unleash tier"..tostring(iMinTier).." rush")
				   		self.m_iFinishedRush = self.m_iPrepareRush
				   		self.m_iPrepareRush = 0
		  			end
		  			
		  		-- Check if rush is still active
		  		elseif (self.m_iPrepareRush == iMinTier) then
		  		
		  			-- Deactivate rush
		  			aitrace("BuildController: Deactivate tier"..tostring(iMinTier).." rush")
		  			self.m_iFinishedRush = iMinTier
		  			self.m_iPrepareRush = 0
		  		end
	  		end
	  		
	  	elseif (sType == "Restrict") then

			-- Restrict squad limit and remove entry
			aitrace("BuildController: Restrict squad limit for "..sName.." to "..tostring(iCount))
			build_manager:SetSquadLimit(sName, math.floor(iCount * fArmyCapModifier + 0.5))
			-- removing is nonsense as it it reset at start of this function
			-- table.remove(self.info.BuildPrograms[BuildBaseStrategy.iBuildProgram], iLoop1)
			-- iBuildProgramSize = iBuildProgramSize - 1
  			iCount = 0
		end
		
		-- Check if we need a Relic
		if (iCurrentInstances < iCount and self:RelicRequired(sName)) then
			
			-- Check AI settings and relics
			if (not CpuManager.AISettings.bRelicUnits or not self:HasRelic()) then
				iCount = 0
			end
		end
		
		-- Check if object should be built
		if (iCurrentInstances < iCount) then
		
			-- Check tier level
			if (iTier < iMinTier) then
				return
			end
			
			-- Check army power
			if (iArmyStrength < iMinArmyStrength) then
				return
			end
			
			-- If requisition or power is rare, don't spend any ressources for units
			if (iRequisition < iMinRequisition or iPower < iMinPower) then
			
				-- Restrict reinforcing and unit building if we have at least one builder
				if (iBuilders > 0) then
					self:SaveRessources(bSaveRessources)
				end
				return
			end
			
			-- Build object
			local bUpdateRessources = false
			if (sType == "Building") then
			
				-- Build building
				local tBuildType = CpuBuildType()
				tBuildType.name = sName
				tBuildType.btype = CpuPrerequisites.BT_Building
				if (self:TryBuild( tBuildType )) then
					aitrace("BuildController: Building "..sName)
					return
				else
					aitrace("BuildController: Building failed => "..sName)
				end
				
			elseif (sType == "Research") then
			
				-- Start research
				local tBuildType = CpuBuildType()
				tBuildType.name = sName
				tBuildType.btype = CpuPrerequisites.BT_Research
				if (self:TryBuild( tBuildType )) then
					aitrace("BuildController: Researching "..sName)
				end
				bUpdateRessources = true
				
			elseif (sType == "Addon") then
			
				-- Build addon
				local tBuildType = CpuBuildType()
				tBuildType.name = sName
				tBuildType.btype = CpuPrerequisites.BT_AddOn
				if (self:TryBuild( tBuildType )) then

					-- Check HQ addons
					if (self:IsTierAddon(sName, 2)) then
						self.m_bHQAddon1 = true
					elseif (self:IsTierAddon(sName, 3)) then
						self.m_bHQAddon2 = true
					end
					aitrace("BuildController: Building addon "..sName)
				end
				bUpdateRessources = true

			elseif (sType == "TurretAddon") then
			
				-- Upgrade turret
				aitrace("BuildController: Building turret addon "..sName)
				self.AddPlan( self, BuildNotifiedAddOnPlan( iID , 0, aTurretPositions) )
				bUpdateRessources = true
				
			elseif (sType == "Unit") then
					
				-- Build unit
				local tBuildType = CpuBuildType()
				tBuildType.btype = CpuPrerequisites.BT_Squad
				tBuildType.name = sName
				if (self:TryBuild( tBuildType )) then
					aitrace("BuildController: Force-building "..sName)
					bBuildUnits = false
					bUpdateRessources = true
				end
			end
			
			-- Update ressources
			if (bUpdateRessources) then
				bSaveRessources = false
				iRequisition = iRequisition - iMinRequisition
				iPower = iPower - iMinPower
			end
		end
	end
end

-- Arkhan 11.2006: Check if we have enough resources for a bigger generator
function BuildBaseStrategy:HasResourcesForBiggerGenerator(iRequisition, iPower)

	-- Check requisition
	if (iRequisition < 300) then
		return false
	end
	return true
end

-- Arkhan 11.2006: Check if we own a relic
function BuildBaseStrategy:HasRelic()

	-- Check all strategic points
	for oStrategicPoint in resource_manager:GetStrategicPointAIs() do
			
		-- Check strategic point
		if (oStrategicPoint:Owner() == cpu_manager.player_id and oStrategicPoint:IsRelic()) then
			return true
		end
	end
	return false
end

-- Lord Cylarne 9/23/15: Check if we own a critical location
function BuildBaseStrategy:HasCriticalLocation()

	-- Check all strategic points
	for oStrategicPoint in resource_manager:GetStrategicPointAIs() do
			
		-- Check strategic point
		if (oStrategicPoint:Owner() == cpu_manager.player_id and oStrategicPoint:IsStrategicObjective()) then
			return true
		end
	end
	return false
end

-- Arkhan 11.2006: Virtual method for checking out relic units
function BuildBaseStrategy:RelicRequired(sName)
	return false
end

-- Lord Cylarne 9/23/15: Virtual method for checking out CL units
function BuildBaseStrategy:CriticalLocationRequired(sName)
	return false
end

-- Arkhan 11.2006: Save ressources
function BuildBaseStrategy:SaveRessources(bSave)
	
	-- Check if it's necessary to save ressources
	if (not bSave) then
		return
	end
	
	-- Check resources
	if (not self:HasResourceOverflow()) then
		
		-- Restrict reinforcing and unit building
		aitrace("BuildController: Restrict reinforcing and unit building!")
		Tactic.Options.can_reinforce = false
		--self.m_bSpendMoney = false
	end
end

-- Arkhan 06.2007: Check if we have a resource overflow
function BuildBaseStrategy:HasResourceOverflow()

	-- Don't reinforce if we've lots of power, rare requisition, and few vehicles
	local iRequisition	= resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Requisition ) / self.m_iTechBreak
	local iPower		= resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Power ) / self.m_iTechBreak
	local iTier			= self:GetTierLevel()
	if ((iTier == 1 and iRequisition > 200 and iPower > 150) or (iTier > 1 and iRequisition > 300 and iPower > 250)) then
		return true
	end
	return false
end

-- Arkhan 11.2006: Check if we can reinforce
function BuildBaseStrategy:CheckReinforce()

	-- Don't reinforce in the first 3 minutes
	if (g_iGMT < 60 * 3) then
		return false
	end

	-- Check resources
	local iRequisition		= resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Requisition ) / self.m_iTechBreak
	local iPower			= resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Power ) / self.m_iTechBreak
	
	-- Keep some resources for strategic points and other things
	if (iRequisition < Tactic.ResourceFloor.requisition or iPower < Tactic.ResourceFloor.power) then
		return false
	end
	
	-- Don't reinforce if we've lots of power, rare requisition, and few vehicles
	local iSupportCapLeft = build_manager:GetSupportCapLeft()
	if (iSupportCapLeft >= 2 and iPower > 800 and iRequisition < 400) then
		return false
	end
	return true
end

-- Arkhan 01.2006: Virtual method to check if force tech should be computed
function BuildBaseStrategy:ForceTech()
	return false
end

-- Arkhan 01.2006: Abstract method to check if an addon is a tier addon
function BuildBaseStrategy:IsTierAddon( sName, iTargetTier )
	return false
end

-- Arkhan 10.2005: Abstract method to get the building for a specific addon
function BuildBaseStrategy:GetAddonBuilding( sType )
	return nil
end

-- Arkhan 03.2002: Dynamic addon
-- Dark40k 10.2008: Added bSingleTier optional parameter to have the addon added only when Tier=iMinTier 
function BuildBaseStrategy:DynamicAddon(sAddonName, iAddonCount, iMinTier, iRequisitionCost, iPowerCost, iMinSquadCap, iMinSupportCap, sSquadName, iSquadMinCount, bSingleTier, iCheckSpend)
        if iCheckSpend==nil then
           iCheckSpend=true
        end
	-- Don't build if we are not allowed to spend money
	if (not self.m_bSpendMoney and iCheckSpend==true) then
		return
	end
	
	-- Check tier level
	-- Dark40k 10.2008: check if bSingleTier is set
	if (self.tierLevel < iMinTier) then
		return
	elseif (self.tierLevel~=iMinTier) and (bSingleTier==true) then
		return
	end
	
	-- Check ressources
	local iRequisition = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Requisition ) / self.m_iTechBreak
	local iPower = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Power ) / self.m_iTechBreak
	if (iRequisition < iRequisitionCost or iPower < iPowerCost) then
		return
	end
	
	-- Check if Relic is required
	if (not self:HasRelic() and self:RelicRequired(sAddonName)) then
		return
	end
	
	-- Check if CR is required
	if (not self:HasCriticalLocation() and self:CriticalLocationRequired(sAddonName)) then
		return
	end
	
	-- Check squad and support cap
	local iSquadCap = self:GetCurrentSquadCap()
	local iSupportCap = build_manager:GetSupportCapCurrentMax() - build_manager:GetSupportCapLeft()
	if (iSquadCap < iMinSquadCap or iSupportCap < iMinSupportCap) then
		return
	end
	
	-- Check squad count
	if (sSquadName ~= nil and self:CountSquads(sSquadName) < iSquadMinCount) then
		return
	end

	-- Get addon ID
	local iID = cpu_manager.stats:GetAddOnID(sAddonName)
	
	-- Check existing addons
	local iBuildingID = cpu_manager.stats:GetBuildingID(self:GetAddonBuilding(sAddonName))
	local iBuildingCount = 0
	local iInstances = 0
	for iLoop1 in self.m_aBuildChannels do
		-- Check for addon building
		if (self.m_aBuildChannels[iLoop1][2] == iBuildingID) then
			iBuildingCount = iBuildingCount + 1
			if (self.m_aBuildChannels[iLoop1][1]:CanAddToQueue(BuildChannelAI.PQ_AddOn, iID) ~= BuildChannelAI.CANBUILD_Ok) then
				iInstances = iInstances + 1
			end
		end
	end
	if (iInstances >= iAddonCount or iBuildingCount <= iInstances) then
		return
	end
	
	-- Check if addon plan exists
	-- dark40k 10.2008 : corrected syntax error : "Build Addon Plan"=>"Build AddOn Plan"
	--if (self:PlanExists("Build AddOn Plan", iID)) then
	--	return
	--end
	
	-- Start addon
	local tBuildType = CpuBuildType()
	tBuildType.name = sAddonName
	tBuildType.btype = CpuPrerequisites.BT_AddOn
	if (self:TryBuild( tBuildType )) then
		aitrace("BuildController: Dynamic build of addon "..sAddonName)
	end
end

-- Arkhan 10.2005: Dynamic research
function BuildBaseStrategy:DynamicResearch(sResearchName, iMinTier, iRequisitionCost, iPowerCost, iMinSquadCap, iMinSupportCap, sSquadName, iSquadMinCount, iCheckSpend)
        if iCheckSpend==nil then
           iCheckSpend=true
        end
	-- Don't build if we are not allowed to spend money
	if (not self.m_bSpendMoney and iCheckSpend==true) then
		return
	end

	-- Check tier level
	if (self.tierLevel < iMinTier) then
		return
	end

	-- Check if Relic is required
	if (not self:HasRelic() and self:RelicRequired(sResearchName)) then
		return
	end

	-- Check if research already exists
	if (cpu_manager.cpu_player:IsResearchComplete(sResearchName)) then
		return
	end
	
	-- Check if research plan exists
	local iID = cpu_manager.stats:GetResearchID(sResearchName)
	if (self:PlanExists("Build Research Plan", iID)) then
		return
	end

	-- Check ressources
	local iRequisition = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Requisition ) / self.m_iTechBreak
	local iPower = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Power ) / self.m_iTechBreak
	if (iRequisition < iRequisitionCost or iPower < iPowerCost) then
		return
	end
	
	-- Check if Relic is required
	if (not self:HasRelic() and self:RelicRequired(sResearchName)) then
		return
	end
	
	-- Check if CR is required
	if (not self:HasCriticalLocation() and self:CriticalLocationRequired(sResearchName)) then
		return
	end
	
	-- Check squad and support cap
	local iSquadCap = self:GetCurrentSquadCap()
	local iSupportCap = build_manager:GetSupportCapCurrentMax() - build_manager:GetSupportCapLeft()
	if (iSquadCap < iMinSquadCap or iSupportCap < iMinSupportCap) then
		return
	end
	
	-- Check squad count
	if (sSquadName ~= nil and self:CountSquads(sSquadName) < iSquadMinCount) then
		return
	end
	
	-- Start research
	local tBuildType = CpuBuildType()
	tBuildType.name = sResearchName
	tBuildType.btype = CpuPrerequisites.BT_Research
	if (self:TryBuild( tBuildType )) then
		aitrace("BuildController: Dynamic research of "..sResearchName)
	end
end

-- Arkhan 11.2005: Dynamic build
function BuildBaseStrategy:DynamicBuild(sBuildingName, iBuildingCount, iMinTier, iMinRequisition, iMinPower, iMinSquadCap, iMinSupportCap, iCheckSpend)
        if iCheckSpend==nil then
           iCheckSpend=true
        end
	-- Don't build if we are not allowed to spend money
	if (not self.m_bSpendMoney and iCheckSpend==true) then
		return
	end
	
	-- Check tier level
	if (self.tierLevel < iMinTier) then
		return
	end

	-- Get building ID
	local iID = cpu_manager.stats:GetBuildingID(sBuildingName)

	-- Return if a build plan for the current building already exists
--	if (self:PlanExists("Build Building Plan", iID)) then
--		return
--	end

	-- Check how many instances of this building exist
	local iInstances = self:GetBuildingCountByBPID(iID, false) + self:PlanCount("Build Building Plan", iID)
	
	-- Return if enough instances exist
	if (iInstances >= iBuildingCount) then
		return
	end

        if self:PlanCount("Build Building Plan", iID)>=2 then
                return
        end

	-- Check ressources
	local iRequisition = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Requisition ) / self.m_iTechBreak
	local iPower = resource_manager:GetResourceAmount():Get( ResourceAmount.RT_Power ) / self.m_iTechBreak
	if (iRequisition < iMinRequisition or iPower < iMinPower) then
		return
	end
	
	-- Check if Relic is required
	if (not self:HasRelic() and self:RelicRequired(sBuildingName)) then
		return
	end
	
	-- Check if CR is required
	if (not self:HasCriticalLocation() and self:CriticalLocationRequired(sBuildingName)) then
		return
	end
	
	-- Check squad and support cap
	local iSquadCap = self:GetCurrentSquadCap()
	local iSupportCap = build_manager:GetSupportCapCurrentMax() - build_manager:GetSupportCapLeft()
	if (iSquadCap < iMinSquadCap or iSupportCap < iMinSupportCap) then
		return
	end
		
	-- Add build plan
	local tBuildType = CpuBuildType()
	tBuildType.name = sBuildingName
	tBuildType.btype = CpuPrerequisites.BT_Building
	if (self:TryBuild( tBuildType )) then
		aitrace("BuildController: Dynamic build of "..sBuildingName)
	end
end

-- Arkhan 10.2005: Returns the current squad cap
function BuildBaseStrategy:GetCurrentSquadCap()

	-- This should normally work
	local iSquadCapLeft			= build_manager:GetSquadCapLeft()
	local iCurrentSquadCapMax	= build_manager:GetSquadCapCurrentMax()
	local iCurrentSquadCap 		= iCurrentSquadCapMax - iSquadCapLeft
	if (iCurrentSquadCap <= 700) then
	-- Kaiser Soze 03.2007
	--Changed to 700 due to the maximun FSR resurce (originale it was 100)
		return iCurrentSquadCap
	end
	
	-- Try alternative way
	aitrace("Function GetSquadCapCurrentMax() screwed up! Try alternative way...")
	iCurrentSquadCap = 0
	for oSquad in cpu_manager.player_stats:GetSquads() do
							
		if (oSquad:IsValid()) then
			
			-- Get squad stats
			local oUnitStats = oSquad:GetStats()

			-- Get squad cap
			if (oUnitStats ~= nil) then
				iCurrentSquadCap = iCurrentSquadCap + oUnitStats:GetSquadCapReq()
			end
		end
	end
	return iCurrentSquadCap
end

-- Arkhan 10.2005: Returns the current squad cap max
function BuildBaseStrategy:GetSquadCapCurrentMax()

	-- This should normally work
	local iSquadCapLeft			= build_manager:GetSquadCapLeft()
	local iCurrentSquadCapMax	= build_manager:GetSquadCapCurrentMax()
	local iCurrentSquadCap 		= iCurrentSquadCapMax - iSquadCapLeft
	if (iCurrentSquadCap <= 700) then
	-- Kaiser Soze 03.2007
	--Changed to 700 due to the maximun FSR resurce (originale it was 100)
		return iCurrentSquadCap
	end
	
	-- Try alternative way
	aitrace("Function GetSquadCapCurrentMax() screwed up! Try alternative way...")
	iCurrentSquadCap = 0
	for oSquad in cpu_manager.player_stats:GetSquads() do
							
		if (oSquad:IsValid()) then
			
			-- Get squad stats
			local oUnitStats = oSquad:GetStats()

			-- Get squad cap
			if (oUnitStats ~= nil) then
				iCurrentSquadCap = iCurrentSquadCap + oUnitStats:GetSquadCapReq()
			end
		end
	end
	return iCurrentSquadCap
end

-- Arkhan 10.2005: Returns the left squad cap
function BuildBaseStrategy:GetSquadCapLeft()

	-- This should normally work
	local iSquadCapLeft	= build_manager:GetSquadCapLeft()
	if (iSquadCapLeft < 0 or iSquadCapLeft > 200) then
		return (self:GetSquadCapCurrentMax() - self:CalculateSquadCap())
	end
	return iSquadCapLeft
end

-- Arkhan 10.2005: Returns the squad cap
function BuildBaseStrategy:GetSquadCap()

	-- This should normally work
	local iCurrentSquadCapMax	= self:GetSquadCapCurrentMax()
	local iSquadCapLeft			= self:GetSquadCapLeft()
	local iSquadCap 			= iCurrentSquadCapMax - iSquadCapLeft
	if (iSquadCap >= 0 and iSquadCap <= 200) then
		return self:CalculateSquadCap()
	end
	return iSquadCap
end

-- Arkhan 10.2005: Returns the current squad cap
function BuildBaseStrategy:CalculateSquadCap()

	-- Check last squad cap calculation time
	if (g_iGMT <= self.m_iLastSquadCapCalculation) then
		return self.m_iSquadCap
	end
	self.m_iLastSquadCapCalculation = g_iGMT

	-- Calculate squad cap
	self.m_iSquadCap = 0
	for oUnit in cpu_manager.player_stats:GetSquads() do
		
		-- Check if unit is valid				
		if (oUnit:IsValid()) then
			
			-- Get squad cap
			local oUnitStats = oUnit:GetStats()
			if (oUnitStats ~= nil) then
				self.m_iSquadCap = self.m_iSquadCap + oUnitStats:GetSquadCapReq()
			end
		end
	end
	return self.m_iSquadCap
end

-- Arkhan 11.2005: Abstract method that returns the squad cap and support cap of the given squad
function BuildBaseStrategy:GetUnitStats(sSquadName)
	return 0, 0
end

-- Arkhan 03.2006: Virtual method to check if a building is allowed to deepstrike military units
function BuildBaseStrategy:MilitaryDeepStrike(iBuildingID)
	return true
end